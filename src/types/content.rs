//! Content-related type definitions for the SDK.
//! 
//! This module defines the types used to represent messages, content blocks, 
//! and other content-related structures in the SDK. These types are modeled 
//! after the Bedrock API.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::tools::{ToolResult, ToolUse};
use super::media::{DocumentContent, ImageContent, VideoContent};

/// Text content to be evaluated by guardrails.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct GuardContentText {
    /// The qualifiers describing the text block.
    pub qualifiers: Vec<GuardQualifier>,
    /// The input text details to be evaluated by the guardrail.
    pub text: String,
}

/// Qualifiers for guard content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GuardQualifier {
    GroundingSource,
    Query,
    GuardContent,
}

/// Content block to be evaluated by guardrails.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct GuardContent {
    /// Text within content block to be evaluated by the guardrail.
    pub text: GuardContentText,
}

/// Contains the reasoning that the model used to return the output.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningTextBlock {
    /// A token that verifies that the reasoning text was generated by the model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
    /// The reasoning that the model used to return the output.
    pub text: String,
}

/// Contains content regarding the reasoning that is carried out by the model.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningContentBlock {
    /// The reasoning that the model used to return the output.
    #[serde(rename = "reasoningText")]
    pub reasoning_text: ReasoningTextBlock,
    /// The content in the reasoning that was encrypted by the model provider for safety reasons.
    #[serde(rename = "redactedContent")]
    pub redacted_content: Vec<u8>,
}

/// A cache point configuration for optimizing conversation history.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CachePoint {
    /// The type of cache point, typically "default".
    pub r#type: String,
}

/// A block of content for a message that you pass to, or receive from, a model.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentBlock {
    /// A cache point configuration to optimize conversation history.
    #[serde(rename = "cachePoint", skip_serializing_if = "Option::is_none")]
    pub cache_point: Option<CachePoint>,
    /// A document to include in the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document: Option<DocumentContent>,
    /// Contains the content to assess with the guardrail.
    #[serde(rename = "guardContent", skip_serializing_if = "Option::is_none")]
    pub guard_content: Option<GuardContent>,
    /// Image to include in the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image: Option<ImageContent>,
    /// Contains content regarding the reasoning that is carried out by the model.
    #[serde(rename = "reasoningContent", skip_serializing_if = "Option::is_none")]
    pub reasoning_content: Option<ReasoningContentBlock>,
    /// Text to include in the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// The result for a tool request that a model makes.
    #[serde(rename = "toolResult", skip_serializing_if = "Option::is_none")]
    pub tool_result: Option<ToolResult>,
    /// Information about a tool use request from a model.
    #[serde(rename = "toolUse", skip_serializing_if = "Option::is_none")]
    pub tool_use: Option<ToolUse>,
    /// Video to include in the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video: Option<VideoContent>,
}

/// Contains configurations for instructions to provide the model for how to handle input.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemContentBlock {
    /// The system prompt text.
    pub text: String,
}

/// A message in a conversation.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Message {
    /// The role of the message sender.
    pub role: MessageRole,
    /// The content of the message.
    pub content: Vec<ContentBlock>,
    /// Optional metadata for the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

/// The role of a message sender.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    User,
    Assistant,
    System,
    Tool,
}

/// A collection of messages.
pub type Messages = Vec<Message>;

impl Message {
    /// Create a new message with the given role and content.
    pub fn new(role: MessageRole, content: Vec<ContentBlock>) -> Self {
        Self {
            role,
            content,
            metadata: None,
        }
    }

    /// Create a new user message with text content.
    pub fn user(text: &str) -> Self {
        Self::new(
            MessageRole::User,
            vec![ContentBlock {
                text: Some(text.to_string()),
                ..Default::default()
            }],
        )
    }

    /// Create a new assistant message with text content.
    pub fn assistant(text: &str) -> Self {
        Self::new(
            MessageRole::Assistant,
            vec![ContentBlock {
                text: Some(text.to_string()),
                ..Default::default()
            }],
        )
    }

    /// Create a new system message with text content.
    pub fn system(text: &str) -> Self {
        Self::new(
            MessageRole::System,
            vec![ContentBlock {
                text: Some(text.to_string()),
                ..Default::default()
            }],
        )
    }

    /// Get the text content from the message.
    pub fn text(&self) -> Option<&str> {
        self.content
            .iter()
            .find_map(|block| block.text.as_deref())
    }

    /// Get all text content from all content blocks, joined with spaces.
    pub fn all_text(&self) -> String {
        let texts: Vec<&str> = self.content
            .iter()
            .filter_map(|block| block.text.as_ref())
            .map(|s| s.as_str())
            .collect();
        texts.join(" ")
    }
}

impl Default for ContentBlock {
    fn default() -> Self {
        Self {
            cache_point: None,
            document: None,
            guard_content: None,
            image: None,
            reasoning_content: None,
            text: None,
            tool_result: None,
            tool_use: None,
            video: None,
        }
    }
}

impl From<&str> for Message {
    fn from(text: &str) -> Self {
        Message::user(text)
    }
}

impl From<String> for Message {
    fn from(text: String) -> Self {
        Message::user(&text)
    }
}
